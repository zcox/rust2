//! Function registry for tool execution

use std::collections::HashMap;
use std::future::Future;

use async_trait::async_trait;
use futures::future::BoxFuture;
use serde::de::DeserializeOwned;
use serde::Serialize;

use super::executor::ToolExecutor;
use crate::llm::ToolDeclaration;

/// Errors that can occur during tool registration
#[derive(Debug, thiserror::Error)]
pub enum RegistryError {
    #[error("Tool name '{name}' does not match declaration name '{declaration_name}'")]
    NameMismatch {
        name: String,
        declaration_name: String,
    },

    #[error("Tool '{name}' is already registered")]
    DuplicateTool { name: String },
}

/// Type alias for boxed async functions
type AsyncToolFn = Box<
    dyn Fn(serde_json::Value) -> BoxFuture<'static, Result<String, String>> + Send + Sync,
>;

/// Entry holding both function and its declaration (internal)
struct ToolEntry {
    function: AsyncToolFn,
    declaration: ToolDeclaration,
}

/// Public struct for registering tools (generated by #[tool] macro)
pub struct ToolRegistration {
    pub name: &'static str,
    pub function: AsyncToolFn,
    pub declaration: ToolDeclaration,
}

/// Registry for managing tool functions
///
/// The `FunctionRegistry` allows you to register Rust functions that can be called by the LLM.
/// It handles automatic deserialization of arguments from JSON and serialization of results back to JSON.
///
/// # Example
///
/// ```ignore
/// use serde::{Deserialize, Serialize};
///
/// #[derive(Deserialize)]
/// struct WeatherArgs {
///     location: String,
/// }
///
/// #[derive(Serialize)]
/// struct WeatherResult {
///     temperature: f32,
///     conditions: String,
/// }
///
/// async fn get_weather(args: WeatherArgs) -> Result<WeatherResult, String> {
///     // Implementation
///     Ok(WeatherResult {
///         temperature: 72.0,
///         conditions: "Sunny".to_string(),
///     })
/// }
///
/// let mut registry = FunctionRegistry::new();
/// let declaration = ToolDeclaration {
///     name: "get_weather".to_string(),
///     description: "Get weather for a location".to_string(),
///     input_schema: serde_json::json!({
///         "type": "object",
///         "properties": {
///             "location": {"type": "string"}
///         }
///     }),
/// };
/// registry.register_async_tool(get_weather, declaration)?;
/// ```
pub struct FunctionRegistry {
    tools: HashMap<String, ToolEntry>,
}

impl FunctionRegistry {
    /// Create a new empty function registry
    pub fn new() -> Self {
        Self {
            tools: HashMap::new(),
        }
    }

    /// Register an async tool function with its declaration
    ///
    /// # Type Parameters
    ///
    /// * `F` - The function type
    /// * `Args` - The argument type (must implement `DeserializeOwned`)
    /// * `R` - The result type (must implement `Serialize`)
    /// * `Fut` - The future type returned by the function
    ///
    /// # Arguments
    ///
    /// * `func` - The async function to execute
    /// * `declaration` - The tool declaration (provides the tool name)
    ///
    /// # Errors
    ///
    /// Returns `RegistryError::DuplicateTool` if the tool is already registered
    pub fn register_async_tool<F, Args, R, Fut>(
        &mut self,
        func: F,
        declaration: ToolDeclaration,
    ) -> Result<(), RegistryError>
    where
        F: Fn(Args) -> Fut + Send + Sync + 'static,
        Args: DeserializeOwned + Send + 'static,
        R: Serialize + Send + 'static,
        Fut: Future<Output = Result<R, String>> + Send + 'static,
    {
        // Check for duplicates
        if self.tools.contains_key(&declaration.name) {
            return Err(RegistryError::DuplicateTool {
                name: declaration.name.clone(),
            });
        }

        // Wrap function (same logic as old register_async)
        let wrapper = move |args_json: serde_json::Value| {
            // Deserialize arguments
            let args = match serde_json::from_value::<Args>(args_json) {
                Ok(args) => args,
                Err(e) => {
                    let err_msg = format!("Failed to deserialize arguments: {}", e);
                    return Box::pin(async move { Err(err_msg) }) as BoxFuture<'static, _>;
                }
            };

            // Call the function
            let future = func(args);

            // Box the future and handle serialization
            Box::pin(async move {
                match future.await {
                    Ok(result) => {
                        // Serialize the result
                        serde_json::to_string(&result)
                            .map_err(|e| format!("Failed to serialize result: {}", e))
                    }
                    Err(e) => Err(e),
                }
            }) as BoxFuture<'static, _>
        };

        // Store atomically
        let name = declaration.name.clone();
        self.tools.insert(
            name,
            ToolEntry {
                function: Box::new(wrapper),
                declaration,
            },
        );

        Ok(())
    }

    /// Convenience method to register a tool from a ToolRegistration struct
    /// (generated by the #[tool] macro)
    ///
    /// This is the simplest registration method - just pass the result of
    /// calling `{tool}_tool::registration()`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// registry.register(calculator_tool::registration())?;
    /// ```
    ///
    /// # Errors
    ///
    /// Returns `RegistryError::NameMismatch` if tool.name doesn't match tool.declaration.name
    /// Returns `RegistryError::DuplicateTool` if the tool is already registered
    pub fn register(&mut self, tool: ToolRegistration) -> Result<(), RegistryError> {
        // Validate that name matches declaration.name
        if tool.name != tool.declaration.name {
            return Err(RegistryError::NameMismatch {
                name: tool.name.to_string(),
                declaration_name: tool.declaration.name.clone(),
            });
        }

        // Check for duplicates
        if self.tools.contains_key(tool.name) {
            return Err(RegistryError::DuplicateTool {
                name: tool.name.to_string(),
            });
        }

        // Store atomically
        self.tools.insert(
            tool.name.to_string(),
            ToolEntry {
                function: tool.function,
                declaration: tool.declaration,
            },
        );

        Ok(())
    }

    /// Register a sync tool function with its declaration
    ///
    /// # Type Parameters
    ///
    /// * `F` - The function type
    /// * `Args` - The argument type (must implement `DeserializeOwned`)
    /// * `R` - The result type (must implement `Serialize`)
    ///
    /// # Arguments
    ///
    /// * `func` - The synchronous function to execute
    /// * `declaration` - The tool declaration (provides the tool name)
    ///
    /// # Errors
    ///
    /// Returns `RegistryError::DuplicateTool` if the tool is already registered
    pub fn register_sync_tool<F, Args, R>(
        &mut self,
        func: F,
        declaration: ToolDeclaration,
    ) -> Result<(), RegistryError>
    where
        F: Fn(Args) -> Result<R, String> + Send + Sync + 'static,
        Args: DeserializeOwned + Send + 'static,
        R: Serialize + Send + 'static,
    {
        // Check for duplicates
        if self.tools.contains_key(&declaration.name) {
            return Err(RegistryError::DuplicateTool {
                name: declaration.name.clone(),
            });
        }

        // Wrap function (same logic as old register_sync)
        let wrapper = move |args_json: serde_json::Value| {
            // Deserialize arguments
            let args = match serde_json::from_value::<Args>(args_json) {
                Ok(args) => args,
                Err(e) => {
                    let err_msg = format!("Failed to deserialize arguments: {}", e);
                    return Box::pin(async move { Err(err_msg) }) as BoxFuture<'static, _>;
                }
            };

            // Call the function
            let result = func(args);

            // Box the result as a future
            Box::pin(async move {
                match result {
                    Ok(result) => {
                        // Serialize the result
                        serde_json::to_string(&result)
                            .map_err(|e| format!("Failed to serialize result: {}", e))
                    }
                    Err(e) => Err(e),
                }
            }) as BoxFuture<'static, _>
        };

        // Store atomically
        let name = declaration.name.clone();
        self.tools.insert(
            name,
            ToolEntry {
                function: Box::new(wrapper),
                declaration,
            },
        );

        Ok(())
    }

    /// Get all tool declarations registered with this registry
    ///
    /// This returns a clone of all declarations that were registered.
    /// Use this when creating an Agent to avoid manually tracking declarations.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let mut registry = FunctionRegistry::new();
    /// registry.register(calculator_tool::registration())?;
    ///
    /// let declarations = registry.get_declarations();  // Get all registered declarations
    /// let agent = Agent::new(
    ///     provider,
    ///     Box::new(registry),
    ///     declarations,
    ///     config,
    ///     system_prompt,
    /// );
    /// ```
    pub fn get_declarations(&self) -> Vec<ToolDeclaration> {
        self.tools
            .values()
            .map(|entry| entry.declaration.clone())
            .collect()
    }

    /// Check if a tool is registered
    pub fn contains(&self, name: &str) -> bool {
        self.tools.contains_key(name)
    }

    /// Get the number of registered tools
    pub fn len(&self) -> usize {
        self.tools.len()
    }

    /// Check if the registry is empty
    pub fn is_empty(&self) -> bool {
        self.tools.is_empty()
    }

    /// Execute a registered function by name
    ///
    /// This is an internal method used by the `ToolExecutor` implementation.
    async fn execute_function(
        &self,
        name: &str,
        arguments: serde_json::Value,
    ) -> Result<String, String> {
        match self.tools.get(name) {
            Some(entry) => (entry.function)(arguments).await,
            None => Err(format!("Unknown tool: {}", name)),
        }
    }
}

impl Default for FunctionRegistry {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl ToolExecutor for FunctionRegistry {
    async fn execute(
        &self,
        _tool_use_id: String,
        name: String,
        arguments: serde_json::Value,
    ) -> Result<String, String> {
        self.execute_function(&name, arguments).await
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde::{Deserialize, Serialize};

    #[derive(Debug, Deserialize, PartialEq)]
    struct AddArgs {
        a: i32,
        b: i32,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq)]
    struct AddResult {
        sum: i32,
    }

    // Helper to create a simple test declaration
    fn create_test_declaration(name: &str, description: &str) -> ToolDeclaration {
        ToolDeclaration {
            name: name.to_string(),
            description: description.to_string(),
            input_schema: serde_json::json!({
                "type": "object",
                "properties": {
                    "a": {"type": "integer"},
                    "b": {"type": "integer"}
                }
            }),
        }
    }

    #[tokio::test]
    async fn test_register_sync_function() {
        let mut registry = FunctionRegistry::new();

        registry
            .register_sync_tool(
                |args: AddArgs| Ok(AddResult { sum: args.a + args.b }),
                create_test_declaration("add", "Add two numbers"),
            )
            .unwrap();

        assert!(registry.contains("add"));
        assert_eq!(registry.len(), 1);
    }

    #[tokio::test]
    async fn test_execute_sync_function() {
        let mut registry = FunctionRegistry::new();

        registry
            .register_sync_tool(
                |args: AddArgs| Ok(AddResult { sum: args.a + args.b }),
                create_test_declaration("add", "Add two numbers"),
            )
            .unwrap();

        let args = serde_json::json!({"a": 5, "b": 3});
        let result = registry.execute_function("add", args).await.unwrap();

        let parsed: AddResult = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed, AddResult { sum: 8 });
    }

    #[tokio::test]
    async fn test_execute_async_function() {
        let mut registry = FunctionRegistry::new();

        registry
            .register_async_tool(
                |args: AddArgs| async move {
                    // Simulate async work
                    tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
                    Ok(AddResult { sum: args.a + args.b })
                },
                create_test_declaration("add_async", "Add two numbers asynchronously"),
            )
            .unwrap();

        let args = serde_json::json!({"a": 10, "b": 20});
        let result = registry.execute_function("add_async", args).await.unwrap();

        let parsed: AddResult = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed, AddResult { sum: 30 });
    }

    #[tokio::test]
    async fn test_function_error() {
        let mut registry = FunctionRegistry::new();

        registry
            .register_sync_tool(
                |args: AddArgs| {
                    if args.b == 0 {
                        Err("Division by zero".to_string())
                    } else {
                        Ok(AddResult { sum: args.a / args.b })
                    }
                },
                create_test_declaration("divide", "Divide two numbers"),
            )
            .unwrap();

        let args = serde_json::json!({"a": 10, "b": 0});
        let result = registry.execute_function("divide", args).await;

        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Division by zero");
    }

    #[tokio::test]
    async fn test_deserialization_error() {
        let mut registry = FunctionRegistry::new();

        registry
            .register_sync_tool(
                |args: AddArgs| Ok(AddResult { sum: args.a + args.b }),
                create_test_declaration("add", "Add two numbers"),
            )
            .unwrap();

        // Invalid arguments (missing field)
        let args = serde_json::json!({"a": 5});
        let result = registry.execute_function("add", args).await;

        assert!(result.is_err());
        assert!(result.unwrap_err().contains("Failed to deserialize arguments"));
    }

    #[tokio::test]
    async fn test_unknown_function() {
        let registry = FunctionRegistry::new();

        let args = serde_json::json!({"a": 5, "b": 3});
        let result = registry.execute_function("unknown", args).await;

        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "Unknown tool: unknown");
    }

    #[tokio::test]
    async fn test_tool_executor_trait() {
        let mut registry = FunctionRegistry::new();

        registry
            .register_sync_tool(
                |args: AddArgs| Ok(AddResult { sum: args.a + args.b }),
                create_test_declaration("add", "Add two numbers"),
            )
            .unwrap();

        let executor: &dyn ToolExecutor = &registry;
        let args = serde_json::json!({"a": 7, "b": 3});
        let result = executor
            .execute("tool-1".to_string(), "add".to_string(), args)
            .await
            .unwrap();

        let parsed: AddResult = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed, AddResult { sum: 10 });
    }

    #[tokio::test]
    async fn test_multiple_functions() {
        let mut registry = FunctionRegistry::new();

        registry
            .register_sync_tool(
                |args: AddArgs| Ok(AddResult { sum: args.a + args.b }),
                create_test_declaration("add", "Add two numbers"),
            )
            .unwrap();

        registry
            .register_sync_tool(
                |args: AddArgs| Ok(AddResult { sum: args.a * args.b }),
                create_test_declaration("multiply", "Multiply two numbers"),
            )
            .unwrap();

        assert_eq!(registry.len(), 2);
        assert!(registry.contains("add"));
        assert!(registry.contains("multiply"));

        let args = serde_json::json!({"a": 3, "b": 4});
        let result = registry.execute_function("multiply", args).await.unwrap();

        let parsed: AddResult = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed, AddResult { sum: 12 });
    }

    #[derive(Debug, Serialize)]
    struct ComplexResult {
        message: String,
        data: Vec<i32>,
        nested: NestedData,
    }

    #[derive(Debug, Serialize)]
    struct NestedData {
        value: String,
    }

    #[derive(Debug, Deserialize)]
    struct EmptyArgs {}

    #[tokio::test]
    async fn test_complex_serialization() {
        let mut registry = FunctionRegistry::new();

        let decl = ToolDeclaration {
            name: "get_data".to_string(),
            description: "Get complex data".to_string(),
            input_schema: serde_json::json!({"type": "object", "properties": {}}),
        };

        registry
            .register_sync_tool(
                |_args: EmptyArgs| {
                    Ok(ComplexResult {
                        message: "Success".to_string(),
                        data: vec![1, 2, 3],
                        nested: NestedData {
                            value: "nested".to_string(),
                        },
                    })
                },
                decl,
            )
            .unwrap();

        let args = serde_json::json!({});
        let result = registry.execute_function("get_data", args).await.unwrap();

        // Verify it's valid JSON
        let parsed: serde_json::Value = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed["message"], "Success");
        assert_eq!(parsed["data"][0], 1);
        assert_eq!(parsed["nested"]["value"], "nested");
    }

    #[tokio::test]
    async fn test_get_declarations() {
        use crate::llm::ToolDeclaration;

        let mut registry = FunctionRegistry::new();

        // Initially no declarations
        assert_eq!(registry.get_declarations().len(), 0);

        // Create a mock declaration
        let decl1 = ToolDeclaration {
            name: "tool1".to_string(),
            description: "First tool".to_string(),
            input_schema: serde_json::json!({
                "type": "object",
                "properties": {}
            }),
        };

        let decl2 = ToolDeclaration {
            name: "tool2".to_string(),
            description: "Second tool".to_string(),
            input_schema: serde_json::json!({
                "type": "object",
                "properties": {}
            }),
        };

        // Register tools with declarations
        registry
            .register_async_tool(|_args: EmptyArgs| async { Ok(()) }, decl1.clone())
            .unwrap();
        registry
            .register_async_tool(|_args: EmptyArgs| async { Ok(()) }, decl2.clone())
            .unwrap();

        // Verify we can get all declarations
        let declarations = registry.get_declarations();
        assert_eq!(declarations.len(), 2);
        // Note: HashMap iteration order is not guaranteed, so we check both are present
        let names: Vec<&str> = declarations.iter().map(|d| d.name.as_str()).collect();
        assert!(names.contains(&"tool1"));
        assert!(names.contains(&"tool2"));

        let tool1_decl = declarations.iter().find(|d| d.name == "tool1").unwrap();
        assert_eq!(tool1_decl.description, "First tool");

        let tool2_decl = declarations.iter().find(|d| d.name == "tool2").unwrap();
        assert_eq!(tool2_decl.description, "Second tool");
    }

    #[tokio::test]
    async fn test_no_name_mismatch_possible_with_direct_methods() {
        let mut registry = FunctionRegistry::new();

        // With the new API, there's no way to have a name mismatch when using
        // register_sync_tool or register_async_tool since they only take a declaration.
        // The name always comes from declaration.name, so it's always consistent!

        registry
            .register_sync_tool(
                |args: AddArgs| Ok(AddResult { sum: args.a + args.b }),
                create_test_declaration("add", "Add two numbers"),
            )
            .unwrap();

        // Verify it registered with the correct name
        assert!(registry.contains("add"));
    }

    #[tokio::test]
    async fn test_duplicate_tool_error() {
        let mut registry = FunctionRegistry::new();

        // Register a tool
        registry
            .register_sync_tool(
                |args: AddArgs| Ok(AddResult { sum: args.a + args.b }),
                create_test_declaration("add", "Add two numbers"),
            )
            .unwrap();

        // Try to register the same tool again
        let result = registry.register_sync_tool(
            |args: AddArgs| Ok(AddResult { sum: args.a * args.b }),
            create_test_declaration("add", "Add two numbers again"),
        );

        assert!(result.is_err());
        match result {
            Err(RegistryError::DuplicateTool { name }) => {
                assert_eq!(name, "add");
            }
            _ => panic!("Expected DuplicateTool error"),
        }
    }

    #[tokio::test]
    async fn test_register_convenience_method() {
        let mut registry = FunctionRegistry::new();

        // Create a ToolRegistration manually (normally this would come from the macro)
        let wrapper = |args_json: serde_json::Value| {
            let args = match serde_json::from_value::<AddArgs>(args_json) {
                Ok(args) => args,
                Err(e) => {
                    let err_msg = format!("Failed to deserialize arguments: {}", e);
                    return Box::pin(async move { Err(err_msg) }) as BoxFuture<'static, _>;
                }
            };

            Box::pin(async move {
                let result = AddResult { sum: args.a + args.b };
                serde_json::to_string(&result)
                    .map_err(|e| format!("Failed to serialize result: {}", e))
            }) as BoxFuture<'static, _>
        };

        let tool_registration = ToolRegistration {
            name: "add",
            function: Box::new(wrapper),
            declaration: create_test_declaration("add", "Add two numbers"),
        };

        // Register using the convenience method
        registry.register(tool_registration).unwrap();

        // Verify it works
        assert!(registry.contains("add"));
        let args = serde_json::json!({"a": 5, "b": 3});
        let result = registry.execute_function("add", args).await.unwrap();
        let parsed: AddResult = serde_json::from_str(&result).unwrap();
        assert_eq!(parsed, AddResult { sum: 8 });
    }

    #[tokio::test]
    async fn test_register_validates_name_match() {
        let mut registry = FunctionRegistry::new();

        // Create a ToolRegistration with mismatched names
        let wrapper = |_args_json: serde_json::Value| {
            Box::pin(async move { Ok("{}".to_string()) }) as BoxFuture<'static, _>
        };

        let tool_registration = ToolRegistration {
            name: "tool1",
            function: Box::new(wrapper),
            declaration: create_test_declaration("tool2", "Different name"),
        };

        let result = registry.register(tool_registration);

        assert!(result.is_err());
        match result {
            Err(RegistryError::NameMismatch { name, declaration_name }) => {
                assert_eq!(name, "tool1");
                assert_eq!(declaration_name, "tool2");
            }
            _ => panic!("Expected NameMismatch error"),
        }
    }
}
