# FunctionRegistry Refactoring Plan

## Summary

This refactoring makes `FunctionRegistry` require both function and declaration at registration time, preventing inconsistent state. It introduces three registration methods:

1. **`register_async_tool(name, func, declaration)`** - Explicit async tool registration
2. **`register_sync_tool(name, func, declaration)`** - Explicit sync tool registration
3. **`register(tool_registration)`** - Convenience method for single-argument registration ⭐

The third option is the recommended approach when using the `#[tool]` macro:

```rust
// Before: 3 separate arguments
registry.register_async_tool(
    calculator_tool::NAME,
    calculator_tool::execute,
    calculator_tool::declaration(),
)?;

// After: Just 1 argument! ✨
registry.register(calculator_tool::registration())?;
```

The `#[tool]` macro generates a `registration()` function that bundles everything (name, wrapped function, and declaration) into a `ToolRegistration` struct, making registration as simple as possible.

## Current Problems

1. **Inconsistent State Possible**: Functions and declarations are stored separately
   - `functions: HashMap<String, AsyncToolFn>`
   - `declarations: Vec<ToolDeclaration>`
   - Can register a function without its declaration via `register_async()` or `register_sync()`
   - Can have declarations without corresponding functions

2. **API Confusion**:
   - `register_async()` and `register_sync()` are public but don't require declarations
   - `register_tool()` only works for async functions (despite the generic-looking name)
   - No symmetry between sync/async registration with declarations

3. **Performance**:
   - Declarations stored in `Vec` - inefficient for lookups if needed
   - No validation that function name matches declaration name

## Requirements

1. **Atomic Registration**: Always register function + declaration together
2. **Type Support**: Support both sync and async tool functions
3. **Consistency**: Impossible to have function without declaration or vice versa
4. **Clear API**:
   - Get all declarations (for Agent initialization)
   - Execute tool by name with arguments (for ToolExecutor trait)
   - Separate methods for sync vs async registration

## Proposed Design

### Data Structure Changes

**Before:**
```rust
pub struct FunctionRegistry {
    functions: HashMap<String, AsyncToolFn>,
    declarations: Vec<ToolDeclaration>,
}
```

**After:**
```rust
/// Entry holding both function and its declaration (internal)
struct ToolEntry {
    function: AsyncToolFn,
    declaration: ToolDeclaration,
}

/// Public struct for registering tools (generated by #[tool] macro)
pub struct ToolRegistration {
    pub name: &'static str,
    pub function: AsyncToolFn,
    pub declaration: ToolDeclaration,
}

pub struct FunctionRegistry {
    tools: HashMap<String, ToolEntry>,
}
```

**Benefits:**
- Atomic storage: function + declaration always together
- Impossible to have inconsistent state
- Efficient lookups by name for both execution and declaration retrieval
- Validates that function name matches declaration name

### API Changes

#### Remove/Make Private

```rust
// REMOVE - don't allow registration without declaration
fn register_async<F, Args, R, Fut>(&mut self, name: impl Into<String>, func: F)
fn register_sync<F, Args, R>(&mut self, name: impl Into<String>, func: F)
```

#### New Public Methods

```rust
/// Register an async tool function with its declaration
pub fn register_async_tool<F, Args, R, Fut>(
    &mut self,
    name: &'static str,
    func: F,
    declaration: ToolDeclaration,
) -> Result<(), RegistryError>
where
    F: Fn(Args) -> Fut + Send + Sync + 'static,
    Args: DeserializeOwned + Send + 'static,
    R: Serialize + Send + 'static,
    Fut: Future<Output = Result<R, String>> + Send + 'static,
{
    // Validate that name matches declaration.name
    if name != declaration.name {
        return Err(RegistryError::NameMismatch { ... });
    }

    // Check for duplicates
    if self.tools.contains_key(name) {
        return Err(RegistryError::DuplicateTool { ... });
    }

    // Wrap function (same logic as current register_async)
    let wrapper = move |args_json: serde_json::Value| { ... };

    // Store atomically
    self.tools.insert(name.to_string(), ToolEntry {
        function: Box::new(wrapper),
        declaration,
    });

    Ok(())
}

/// Register a sync tool function with its declaration
pub fn register_sync_tool<F, Args, R>(
    &mut self,
    name: &'static str,
    func: F,
    declaration: ToolDeclaration,
) -> Result<(), RegistryError>
where
    F: Fn(Args) -> Result<R, String> + Send + Sync + 'static,
    Args: DeserializeOwned + Send + 'static,
    R: Serialize + Send + 'static,
{
    // Same validation as async version
    if name != declaration.name {
        return Err(RegistryError::NameMismatch { ... });
    }

    if self.tools.contains_key(name) {
        return Err(RegistryError::DuplicateTool { ... });
    }

    // Wrap function (same logic as current register_sync)
    let wrapper = move |args_json: serde_json::Value| { ... };

    // Store atomically
    self.tools.insert(name.to_string(), ToolEntry {
        function: Box::new(wrapper),
        declaration,
    });

    Ok(())
}

/// Convenience method to register a tool from a ToolRegistration struct
/// (generated by the #[tool] macro)
///
/// This is the simplest registration method - just pass the result of
/// calling `{tool}_tool::registration()`.
///
/// # Example
/// ```ignore
/// registry.register(calculator_tool::registration())?;
/// ```
pub fn register(&mut self, tool: ToolRegistration) -> Result<(), RegistryError> {
    // Validate that name matches declaration.name
    if tool.name != tool.declaration.name {
        return Err(RegistryError::NameMismatch {
            name: tool.name.to_string(),
            declaration_name: tool.declaration.name.clone(),
        });
    }

    // Check for duplicates
    if self.tools.contains_key(tool.name) {
        return Err(RegistryError::DuplicateTool {
            name: tool.name.to_string(),
        });
    }

    // Store atomically
    self.tools.insert(tool.name.to_string(), ToolEntry {
        function: tool.function,
        declaration: tool.declaration,
    });

    Ok(())
}

/// Get all tool declarations (for Agent initialization)
pub fn get_declarations(&self) -> Vec<ToolDeclaration> {
    self.tools
        .values()
        .map(|entry| entry.declaration.clone())
        .collect()
}

/// Check if a tool is registered
pub fn contains(&self, name: &str) -> bool {
    self.tools.contains_key(name)
}

/// Get number of registered tools
pub fn len(&self) -> usize {
    self.tools.len()
}

/// Check if registry is empty
pub fn is_empty(&self) -> bool {
    self.tools.is_empty()
}

/// Execute a tool by name (internal, used by ToolExecutor trait)
async fn execute_function(
    &self,
    name: &str,
    arguments: serde_json::Value,
) -> Result<String, String> {
    match self.tools.get(name) {
        Some(entry) => (entry.function)(arguments).await,
        None => Err(format!("Unknown tool: {}", name)),
    }
}
```

### Error Type

Add a proper error type for registration:

```rust
#[derive(Debug, thiserror::Error)]
pub enum RegistryError {
    #[error("Tool name '{name}' does not match declaration name '{declaration_name}'")]
    NameMismatch {
        name: String,
        declaration_name: String,
    },

    #[error("Tool '{name}' is already registered")]
    DuplicateTool { name: String },
}
```

### Usage Examples

**Before (problematic):**
```rust
let mut registry = FunctionRegistry::new();

// Can register function without declaration - BAD!
registry.register_async("calculator", calculator);

// Manually create declaration separately - error-prone!
let declarations = vec![ToolDeclaration { ... }];
```

**After (explicit registration):**
```rust
let mut registry = FunctionRegistry::new();

// Must register with declaration - GOOD!
registry.register_async_tool(
    calculator_tool::NAME,
    calculator_tool::execute,
    calculator_tool::declaration(),
)?;

// Declarations automatically managed
let declarations = registry.get_declarations();
```

**After (convenience method - BEST):**
```rust
let mut registry = FunctionRegistry::new();

// Single argument - simplest approach!
registry.register(calculator_tool::registration())?;

// Declarations automatically managed
let declarations = registry.get_declarations();
```

## Integration with #[tool] Macro

The convenience `register()` method is designed to work seamlessly with the `#[tool]` macro. The macro will generate a `registration()` function that returns a `ToolRegistration` struct with everything pre-packaged:

### What the macro generates:

```rust
// User writes:
#[tool(description = "Perform basic arithmetic operations")]
async fn calculator(args: CalculatorArgs) -> Result<CalculatorResult, String> {
    // Implementation
}

// Macro generates:
pub mod calculator_tool {
    pub const NAME: &'static str = "calculator";

    pub fn declaration() -> ToolDeclaration {
        ToolDeclaration {
            name: "calculator".to_string(),
            description: "Perform basic arithmetic operations".to_string(),
            input_schema: serde_json::to_value(&schema_for!(CalculatorArgs))
                .expect("Failed to serialize schema"),
        }
    }

    pub use super::calculator as execute;

    // NEW: Convenience function for one-step registration
    pub fn registration() -> ToolRegistration {
        // Wrapper function (same logic as register_async_tool internals)
        let wrapper = move |args_json: serde_json::Value| {
            let args = match serde_json::from_value::<CalculatorArgs>(args_json) {
                Ok(args) => args,
                Err(e) => {
                    let err_msg = format!("Failed to deserialize arguments: {}", e);
                    return Box::pin(async move { Err(err_msg) }) as BoxFuture<'static, _>;
                }
            };

            let future = execute(args);

            Box::pin(async move {
                match future.await {
                    Ok(result) => {
                        serde_json::to_string(&result)
                            .map_err(|e| format!("Failed to serialize result: {}", e))
                    }
                    Err(e) => Err(e),
                }
            }) as BoxFuture<'static, _>
        };

        ToolRegistration {
            name: NAME,
            function: Box::new(wrapper),
            declaration: declaration(),
        }
    }
}
```

### Benefits of this approach:

1. **Single argument**: `registry.register(calculator_tool::registration())?` - can't get simpler!
2. **Type-safe**: All the type information is captured in the macro-generated code
3. **Consistent**: Works for both sync and async functions (macro handles the difference)
4. **Self-contained**: The tool module has everything needed for registration
5. **Flexible**: Users can still use explicit `register_async_tool()` if they prefer

### Comparison of registration approaches:

```rust
// Approach 1: Explicit (most control, most verbose)
registry.register_async_tool(
    calculator_tool::NAME,
    calculator_tool::execute,
    calculator_tool::declaration(),
)?;

// Approach 2: Convenience (simplest, recommended)
registry.register(calculator_tool::registration())?;

// Approach 3: Multiple tools at once (using helper macro - future)
register_tools!(registry, [
    calculator_tool,
    weather_tool,
    database_tool,
])?;
```

## Implementation Steps

### Step 1: Add Error Type
- Create `RegistryError` enum
- Add to `src/llm/tools/mod.rs` exports

### Step 2: Refactor Data Structure
- Add `ToolEntry` struct (private)
- Add `ToolRegistration` struct (public)
- Change `FunctionRegistry::tools` field
- Update `new()` method

### Step 3: Implement New Registration Methods
- Implement `register_async_tool()` with validation
- Implement `register_sync_tool()` with validation
- Implement `register()` convenience method for `ToolRegistration`
- Remove `register_async()` and `register_sync()` (or inline the wrapping logic)

### Step 4: Update Existing Methods
- Update `get_declarations()` to iterate over `tools` values
- Update `execute_function()` to use `tools` HashMap
- Keep `contains()`, `len()`, `is_empty()` with minimal changes

### Step 5: Update ToolExecutor Implementation
- No changes needed - still calls `execute_function()`

### Step 6: Update Tests
- Update `test_register_sync_function()` to use `register_sync_tool()`
- Update `test_execute_sync_function()` to use `register_sync_tool()`
- Update `test_execute_async_function()` to use `register_async_tool()`
- Update `test_function_error()` to use `register_sync_tool()`
- Update all other tests
- Add new tests:
  - Test name mismatch validation
  - Test duplicate tool detection
  - Test that declarations match registered tools
  - Test `register()` convenience method with manually created `ToolRegistration`

### Step 7: Update Documentation
- Update struct-level doc comment example
- Update method doc comments
- Update `register_async_tool()` and `register_sync_tool()` docs
- Add migration guide in doc comments

### Step 8: Update Examples
- Update `examples/agent_calculator.rs` to use new API
- Ensure all examples compile and run

## Migration Guide

### For Users Currently Using Old API

**Old code:**
```rust
registry.register_async("calculator", calculator);
let declarations = vec![
    ToolDeclaration {
        name: "calculator".to_string(),
        description: "...".to_string(),
        input_schema: serde_json::json!({ ... }),
    }
];
```

**New code:**
```rust
registry.register_async_tool(
    "calculator",
    calculator,
    ToolDeclaration {
        name: "calculator".to_string(),
        description: "...".to_string(),
        input_schema: serde_json::json!({ ... }),
    },
)?;

let declarations = registry.get_declarations();
```

**With `#[tool]` macro - explicit:**
```rust
registry.register_async_tool(
    calculator_tool::NAME,
    calculator_tool::execute,
    calculator_tool::declaration(),
)?;

let declarations = registry.get_declarations();
```

**With `#[tool]` macro - convenience (recommended):**
```rust
// Just one argument!
registry.register(calculator_tool::registration())?;

let declarations = registry.get_declarations();
```

## Validation

### Compile-time Guarantees
- ✅ Can't register function without declaration
- ✅ Can't register declaration without function
- ✅ Type safety for Args (Deserialize) and Result (Serialize)

### Runtime Guarantees
- ✅ Function name matches declaration name
- ✅ No duplicate tool registrations
- ✅ All registered functions have declarations
- ✅ All declarations have corresponding functions

## Benefits

1. **Safety**: Impossible to have inconsistent state
2. **Clarity**: Clear API with explicit sync/async separation
3. **Ergonomics**:
   - `get_declarations()` automatically includes all registered tools
   - `register()` convenience method for one-argument registration with `#[tool]` macro
4. **Validation**: Name matching and duplicate detection
5. **Performance**: HashMap for both functions and declarations
6. **Maintainability**: Single source of truth for tool registration
7. **Simplicity**: With macro, registration is just `registry.register(tool::registration())?`

## Open Questions

1. **Return type**: Should registration return `Result<(), RegistryError>` or panic on errors?
   - **Recommendation**: Return `Result` for better error handling

2. **Name parameter**: Should it be `&'static str` or `impl Into<String>`?
   - **Recommendation**: `&'static str` to match macro-generated code pattern

3. **Backward compatibility**: Should we keep old methods deprecated or remove them?
   - **Recommendation**: Remove since this is pre-1.0 and breaking is acceptable

4. **Builder pattern**: Should we add a builder for fluent registration?
   ```rust
   registry.register()
       .name("calculator")
       .async_function(calculator)
       .declaration(calculator_tool::declaration())
       .build()?;
   ```
   - **Recommendation**: Not needed, current API is simple enough

## Success Criteria

- ✅ All tests pass with new API
- ✅ Examples compile and run correctly
- ✅ Cannot register function without declaration
- ✅ Cannot have inconsistent state between functions and declarations
- ✅ Clear separation between sync and async registration
- ✅ Proper error handling with informative messages
- ✅ Documentation updated with examples and migration guide
